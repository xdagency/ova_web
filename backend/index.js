/* Requires */
const   app = require('express')(),
        http = require('http').Server(app),
        io = require('socket.io')(http),
        bodyParser = require('body-parser'),
        mongoose = require('mongoose'),
        Dictionary = require('oxford-dictionary-api'),
        randomize = require('randomatic'),
        wordscramble = require('wordscramble');


/* headers to fix CORS issues */
app.use((req, res, next) => {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
    next();
});

/* MongoDB Connection stuff */
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost/ova');
// set db as the variable for the mongoose connection
const db = mongoose.connection;
// on open event, console log that we've made a connection
db.on('open', () => {
    console.log('connected to MongoDB - Ova');
});
// DB Schemas
const Game = require('./models/Game');
const User = require('./models/User');



/* Set the port */
const PORT = process.env.PORT || 8081;


/* Bring in config file */
const config = require('./config');


// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }));

// parse application/json
app.use(bodyParser.json());

// Point to a public folder
// app.use(express.static('public'));


/* Oxford Dictionary API */

// Define dictionary api variables from config file
let app_id = config.DICT_APP_ID;
let app_key = config.DICT_APP_KEY;

// Dictionary constructor
let dict = new Dictionary(app_id, app_key);


// Array of active games backend is serving
let activeGames = [];

// Total Games
const totalRounds = 3;


// List of predetermined words
// TODO: Grab a word, of the correct length, from the library API
let words = [
    ['bake', 'rake', 'dare', 'heat', 'team', 'tomb', 'boom', 'done', 'arch', 'bark', 'bend', 'soon', 'meat', 'sand', 'pain', 'take', 'talk', 'down', 'mean', 'that', 'glow'],
    ['apple', 'beach', 'break', 'clean', 'clock', 'dance', 'equal', 'front', 'giant', 'image', 'model', 'photo', 'quiet', 'sleep', 'hotel', 'tough', 'train', 'woman', 'young', 'water'],
    ['breath', 'friend', 'animal', 'attack', 'camera', 'coffee', 'escape', 'famous', 'height', 'memory', 'modern', 'office', 'pretty', 'public', 'sample', 'silent', 'theory', 'yellow', 'artist', 'author'],
    ['frazzle', 'ability', 'airport', 'another', 'concert', 'country', 'deliver', 'journey', 'obvious', 'protect', 'subject', 'weekend', 'website', 'retired', 'printer', 'popular', 'picture', 'mistake', 'married', 'minimal'],
    ['accident', 'academic', 'baseball', 'calendar', 'business', 'computer', 'discount', 'envelope', 'hospital', 'language', 'majority', 'military', 'notebook', 'painting', 'princess', 'struggle', 'tomorrow', 'triangle', 'birthday', 'contract']
]


/* Routes */

// GET route, which will return a random word of proper length
app.get('/word', (req, res) => {

    // get the round
    let round = req.query.round - 1;

    // send back a random word from the round-specific array
    res.json({ word: words[round][Math.floor(Math.random() * words[round].length)] });

});

// POST route, which checks dictionary API to see if it's a valid word
app.post('/word', (req, res) => {

    let wordToCheck = req.body.word;

    // console.log('word submitted:', wordToCheck);

    dict.find(wordToCheck, (err, data) => {
        
        if (err) {
            // console.log('error:', err);
            res.sendStatus(404);
            return;
        }

        res.sendStatus(200);
    });

});


// POST route, which saves a new game & player to DB
// Or adds a user to an existing game
app.post('/save-game', (req, res) => {

    // ~~~FOR LATER: DB Stuff~~~
    
    // Create a new player object (user a) that will be saved in DB
    let userA = User({
        nickname: req.body.user_a_name,
    });

    // Create user A
    userA.save()
        
        // Saved user promise
        .then(savedUser => {
            
            // console.log('===== user added =====\n', savedUser);
            
            // Create a new game
            // TODO: Game ID should be what was generated by MongoDB
            let newGame = Game({
                game_id: req.body.game_id,
                users: [savedUser._id],
                user_a_score: req.body.user_a_score,
                user_b_score: req.body.user_b_score
            });
            
            // send back data to front end
            // res.status(200).json(newGame);

            // Save the game
            return newGame.save();
        
        })

        .then(savedGame => {

            // Create user B
            let userB = User({
                nickname: req.body.user_b_name,
            })

            return userB.save();

        })

        .then(savedUser => {

            Game.findOneAndUpdate(
                { game_id: req.body.game_id },
                { $push: { users: savedUser._id } },
                { $set: { updated_at: Date.now() } },
                (err, res) => {
                    if (err) {
                        console.log('Error finding and upading game in MongoDB:', err);
                        return;
                    }

                    // console.log(res);
            });

        })

        // Saved game promise
        // .then(savedGame => {
        //     console.log('===== game added/updated =====\n', savedGame);
        // })

        // error promise
        .catch(error => {
            console.log('Error saving game state to MongoDB:', error);
        });

});

// GET route, which will return server homepage.
app.get('/*', function(req, res) {
    res.sendFile(path.join(__dirname, 'path/to/your/index.html'), function(err) {
        if (err) {
            res.status(500).send(err)
        }
    });
});


/* Listen */
http.listen(PORT, () => {
    console.log('Up on port', PORT);
})


/* Sockets */

io.on('connection', function(socket) {

    // a user has connected to a socket
    console.log('Socket connection made', socket.id);


    // CREATE GAME - A user has started a new game
    socket.on('create-game', (data) => {

        let currGameIndex = '';
        let currGameID = '';


        // Generate a random ID
        currGameID = randomize('A', 4);

        let newGame = {
            game_id: currGameID,
            game_round: 1,
            letter_count: 4,
            user_a: { s_id: socket.id, nickname: data.nickname, word: '', s_word: '', score: 0 },
            user_b: { s_id: '', nickname: '', word: '', s_word: '', score: 0 }
        }


        // Push this 'game' to the games array and assign all it's starting values
        activeGames.push(newGame);


        // Join the socket room
        socket.join(currGameID, () => {
        })


        // See the new game we just created
        // console.log('\n===== game created =====\n', newGame);


        // Emit back the game ID to user A
        socket.emit('game-info', { 
            game_id: currGameID
        });

    });


    // JOIN GAME - A user has joined an existing game
    socket.on('join-game', (data) => {

        // data emitted from frontend
        // console.log('data:', data);

        // Find the correct game id
        let theGame = activeGames.find((elem) => {
            return elem = elem.game_id === data.game_id;
        });

        // Catch a socket trying to hit 'join-game' without a gameID
        if (!data.game_id) {
            console.log('\n===== Phantom ===== \n', socket.id);
            return;
        }

        // Check if we found a game ID based on what user B enetered on their end
        if (theGame.game_id !== '') {

            // Check if there are already 2 players
            // Send back a full status to front end and end function
            if (theGame.user_b.s_id !== '') {
                socket.emit('game-status', {
                    game: 'full'
                });
                return;
            }
            
            // Set the nickname and Socket ID of player B
            theGame.user_b.nickname = data.nickname;
            theGame.user_b.s_id = socket.id;

            // Send back what we found
            // Which is what we have in the 'game state' on server
            socket.emit('game-status', {
                game: theGame,
                game_id: theGame.game_id,
                user_a_name: theGame.user_a.nickname
            });
            
            // Join the socket room
            socket.join(theGame.game_id, () => {
                // console.log('socket', socket.id, 'has joined', socket.rooms)
                // Emit user B's name back to player A
                socket.to(theGame.game_id).emit('player-join', {
                    user_b_name: data.nickname
                })
            });

        }

        // console.log('\n===== player joined ===== \n', theGame);

    });


    // SUBMIT WORD - A user has submitted a word from the /word screen
    socket.on('submit-word', (data) => {

        // Find the correct game id
        let theGame = activeGames.find((elem) => {
            return elem = elem.game_id === data.game_id;
        })

        // Log the details found
        // console.log(foundGameID, foundGameIndex);

        // Scramble the word
        let s_word = wordscramble.scramble(data.word);

        // Find the correct user to map word (and scrambled word) to
        if (socket.id === theGame.user_a.s_id) {
            // User A
            theGame.user_a.word = data.word;
            theGame.user_a.s_word = s_word;
        } else {
            // User B
            theGame.user_b.word = data.word;
            theGame.user_b.s_word = s_word;
        }

        // console.log('\n===== Word added ===== \n', theGame);

        // Check if both words have been submitted
        // If true, game can start
        if (theGame.user_a.word !== '' && theGame.user_b.word !== '') {
            
            // Emit to everyone in 'room'
            io.in(theGame.game_id).emit('game-start', {
                game_id: theGame.game_id,
                user_a_word: theGame.user_a.s_word,
                user_b_word: theGame.user_b.s_word
            });
        }

    });


    // GUESS WORD - A user has made a guess on the scrambled word
    socket.on('guess', (data) => {
    
        // Find the correct game id
        let theGameIndex = 0;
        let theGame = activeGames.find((elem, i) => {
            theGameIndex = i;
            return elem = elem.game_id === data.game_id;
        });

        // console.log('theGame:', theGame);
        // console.log('\n===== new guess =====\n user', data.user, 'guessed:', data.guess);

        // check if it's correct
        // User A is correct
        if (data.user === 'a' && data.guess.toUpperCase() === theGame.user_b.word.toUpperCase()) {

            updateGameState('a', theGame.game_id, theGameIndex);

        // User B is correct
        } else if (data.user === 'b' && data.guess.toUpperCase() === theGame.user_a.word.toUpperCase()) {

            updateGameState('b', theGame.game_id, theGameIndex);

        } else {
            // Wrong guess
            socket.emit('wrong');
        }

    });


    socket.on('rematch', (data) => {

        // Find the correct game id
        let theGame = activeGames.find((elem) => {
            return elem = elem.game_id === data.game_id;
        })

        // reset the scores to 0
        theGame.user_a.score = 0;
        theGame.user_a.score = 0;
        
        // Emit to everyone in 'room'
        io.in(theGame.game_id).emit('start-rematch', {
            game_id: theGame.game_id,
            user_a_score: theGame.user_a.score,
            user_b_score: theGame.user_b.score
        });

    })

    
    // Disconnect event
    socket.on('disconnect', function() {

        // Find the right game
        let droppedGame;
        // Also find the player who dropped and send to frontend
        let droppedPlayer;

        for (let i = 0; i < activeGames.length; i++) {

            if (socket.id === activeGames[i].user_a.s_id || socket.id === activeGames[i].user_b.s_id) {
                droppedGame = activeGames[i].game_id;
            }

        }

        // If someone disconnects, let the group know
        socket.to(droppedGame).emit('player-drop', {})

        // Log when a user has lost connection with their socket
        console.log('Socket disconnected.', socket.id);

    });

});


// f- updating game state when a user gets a point
// takes in the user (a or b), the game id, and the game index
function updateGameState(u, id, i) {
    
    // increment round
    activeGames[i].game_round += 1;

    // increment user score
    u === 'a' ? activeGames[i].user_a.score += 1 : activeGames[i].user_b.score += 1;

    // increment letterCount
    activeGames[i].letter_count += 1;

    // clear words
    activeGames[i].user_a.word = '';
    activeGames[i].user_a.s_word = '';
    activeGames[i].user_b.word = '';
    activeGames[i].user_b.s_word = '';

    // emit the game winner if someone has reached 3 points
    if (activeGames[i].user_a.score === totalRounds || activeGames[i].user_b.score === totalRounds) {
        io.in(id).emit('game-over', {
            game: activeGames[i]
        });
    // or emit a round end when a user guesses a word correctly
    } else {
        io.in(id).emit('round-end', { 
            game_round: activeGames[i].game_round,
            letter_count: activeGames[i].letter_count,
            user_a_score: activeGames[i].user_a.score,
            user_b_score: activeGames[i].user_b.score,
            winner: u
        });
    }

    // console.log('\n===== Game updated ===== \n', 'Game', activeGames[i].game_id, '\nRound', activeGames[i].game_round, '\nLetter count', activeGames[i].letter_count);

}

// f- Add new user to DB and add/update a game in DB
function addNewUser() {
}
